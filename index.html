<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2c3e50">
    <title>Educational Car Game - Simple</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #27ae60;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #questionDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
        }
        
        #scoreDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            z-index: 100;
        }
        
        #debugInfo {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            font-size: 10px;
            z-index: 100;
        }
        
        /* Always landscape - no portrait handling */
        
        @media (orientation: landscape) {
            #questionDisplay {
                font-size: 14px;
                padding: 8px;
            }
            
            #scoreDisplay {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            #instructions {
                font-size: 10px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="questionDisplay">Collect only correct Python!</div>
        <div id="scoreDisplay">Correct: 0 | Wrong: 0</div>
        <div id="instructions">Touch and drag to move the car, or tilt your phone!</div>
        <div id="debugInfo">Loading...</div>
        <div id="tiltStatus" style="position: absolute; top: 110px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px; font-size: 10px; z-index: 100;">
            Tilt: Not Working
        </div>
        <button id="enableTiltBtn" style="position: absolute; top: 80px; left: 10px; background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;">
            Enable Tilt
        </button>
        <button id="uploadBtn" style="position: absolute; top: 80px; left: 140px; background: #8e44ad; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;">
            Upload Content
        </button>
        <input id="uploadInput" type="file" accept=".json,.csv" style="display:none" />
        <button id="downloadJsonBtn" style="position: absolute; top: 80px; left: 260px; background: #16a085; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;">
            Download Sample JSON
        </button>
        <button id="downloadCsvBtn" style="position: absolute; top: 80px; left: 420px; background: #f39c12; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;">
            Download Sample CSV
        </button>
    </div>
    
    <script>
        console.log('Simple game starting...');
        
        // Get elements
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');
        var debugInfo = document.getElementById('debugInfo');
        
        // Set canvas size - consistent base size, scaled for larger screens
        function setCanvasSize() {
            // Base dimensions (16:9 aspect ratio for modern devices)
            var baseWidth = 1280;
            var baseHeight = 720;
            
            // Calculate scale factor based on screen size
            var screenWidth = Math.max(window.innerWidth, window.innerHeight);
            var screenHeight = Math.min(window.innerWidth, window.innerHeight);
            
            // Scale up for larger screens, but keep proportions
            var scaleX = screenWidth / baseWidth;
            var scaleY = screenHeight / baseHeight;
            var scale = Math.min(scaleX, scaleY, 2); // Max 2x scale for very large screens
            
            // Adjust game speed based on scale to maintain consistent feel
            gameSpeed = baseGameSpeed * scale;
            
            // Set canvas to base size (game logic uses these dimensions)
            canvas.width = baseWidth;
            canvas.height = baseHeight;
            
            // Scale the display size
            var displayWidth = baseWidth * scale;
            var displayHeight = baseHeight * scale;
            
            // Center canvas
            canvas.style.position = 'absolute';
            canvas.style.top = '50%';
            canvas.style.left = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
        }
        setCanvasSize();
        
        // Update debug
        debugInfo.innerHTML = 'Canvas: ' + canvas.width + 'x' + canvas.height;
        
        // Game variables
        var carX = canvas.width / 2;
        var carY = canvas.height - 100;
        var objects = [];
        var correctCount = 0;
        var wrongCount = 0;
        var isDragging = false;
        var tiltX = 0;
        var tiltEnabled = false;
        var roadOffset = 0; // For scrolling road effect
        var baseGameSpeed = 2; // Base speed for mobile
        var gameSpeed = 2; // Will be adjusted based on screen scale
        var carSteering = 0; // Car's current steering direction (-1 to 1)
        var carVelocity = 0; // Car's horizontal velocity
        
        // Background image system
        var roadBackground = null;
        var backgroundLoaded = false;
        
        // Spawn control (consistent pacing)
        var spawnIntervalMs = 1800; // base interval between spawns (increased for more thinking time)
        var spawnJitterMs = 600;   // random variation to avoid perfect rhythm
        var nextSpawnAt = 0;       // timestamp (ms) when next spawn is allowed
        var maxObjects = 2;        // cap concurrent objects (reduced for less clutter)
        var minLaneGapPx = 200;    // minimal vertical gap within same lane (increased)
        var lastSpawnLane = -1;    // remember previous lane to rotate fairly

        // Content state (starts empty - must be uploaded)
        var contentQuestion = '';
        var contentCorrect = [];
        var contentIncorrect = [];
        var gameStarted = false;
        
        // Track which items have been used (to avoid repeats)
        var usedCorrectItems = [];
        var usedIncorrectItems = [];
        var gameEnded = false;

        function setQuestion(text) {
            var q = document.getElementById('questionDisplay');
            if (q) q.textContent = text;
        }
        
        // Show upload prompt initially
        function showUploadPrompt() {
            setQuestion('Please upload content to start the game!');
        }
        showUploadPrompt();

        // Upload content handlers
        var uploadBtn = document.getElementById('uploadBtn');
        var uploadInput = document.getElementById('uploadInput');
        if (uploadBtn && uploadInput) {
            uploadBtn.addEventListener('click', function() { uploadInput.click(); });
            uploadInput.addEventListener('change', function(ev) {
                var file = ev.target.files && ev.target.files[0];
                if (!file) return;
                var reader = new FileReader();
                reader.onload = function() {
                    try {
                        var text = String(reader.result || '');
                        if (/^\s*\{/.test(text)) {
                            // JSON
                            var data = JSON.parse(text);
                            applyUploadedContent(data);
                        } else {
                            // CSV
                            var data = parseCSV(text);
                            applyUploadedContent(data);
                        }
                        // Reset input
                        uploadInput.value = '';
                        alert('Content loaded successfully.');
                    } catch (e) {
                        console.error(e);
                        alert('Failed to load content. Please upload valid JSON or CSV.');
                    }
                };
                reader.readAsText(file);
            });
        }

        // Sample content (Big Data topic)
        function getSampleContent() {
            return {
                question: "Collect only things that are 'big data'",
                correct: [
                    'Social media activity logs',
                    'IoT sensor streams from thousands of devices',
                    'Clickstream data from a major e‑commerce site',
                    'Web server logs at internet scale',
                    'Satellite imagery archives updated daily',
                    'Global financial transaction streams',
                    'Telemetry from millions of connected cars',
                    'Genome sequencing datasets across populations',
                    'Email delivery logs from a large provider',
                    'Ad impression and auction logs'
                ],
                incorrect: [
                    'A 2 GB video file',
                    'A ZIP of vacation photos',
                    'A single machine\'s log file',
                    'An Excel sheet with thousands of rows',
                    'A local database with 100k records',
                    'A PDF archive of reports',
                    'A full hard‑drive backup',
                    'One HD movie file',
                    'A large PSD design file',
                    'A 500 MB CSV export'
                ]
            };
        }

        function downloadBlob(filename, text, mime) {
            var blob = new Blob([text], { type: mime || 'text/plain' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(function(){
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }

        function downloadSampleJSON() {
            var data = getSampleContent();
            var text = JSON.stringify(data, null, 2);
            downloadBlob('sample-content.json', text, 'application/json');
        }

        function downloadSampleCSV() {
            var data = getSampleContent();
            var lines = [];
            lines.push('type,text,question');
            // Put question only on the first row to keep it concise
            if (data.correct && data.correct.length) {
                lines.push('correct,"' + data.correct[0].replace(/"/g,'""') + '","' + data.question.replace(/"/g,'""') + '"');
                for (var i=1;i<data.correct.length;i++) {
                    lines.push('correct,"' + data.correct[i].replace(/"/g,'""') + '",');
                }
            }
            if (data.incorrect && data.incorrect.length) {
                for (var j=0;j<data.incorrect.length;j++) {
                    lines.push('incorrect,"' + data.incorrect[j].replace(/"/g,'""') + '",');
                }
            }
            downloadBlob('sample-content.csv', lines.join('\n'), 'text/csv');
        }

        // Wire sample download buttons
        var downloadJsonBtn = document.getElementById('downloadJsonBtn');
        var downloadCsvBtn = document.getElementById('downloadCsvBtn');
        if (downloadJsonBtn) downloadJsonBtn.addEventListener('click', downloadSampleJSON);
        if (downloadCsvBtn) downloadCsvBtn.addEventListener('click', downloadSampleCSV);

        function applyUploadedContent(data) {
            // JSON format: { question: string, correct: string[], incorrect: string[] }
            // CSV parsed format: { question, correct, incorrect }
            var q = data.question || 'Collect the correct items!';
            var corr = Array.isArray(data.correct) ? data.correct : [];
            var inc = Array.isArray(data.incorrect) ? data.incorrect : [];
            if (!corr.length || !inc.length) throw new Error('Lists cannot be empty');
            contentQuestion = q;
            contentCorrect = corr;
            contentIncorrect = inc;
            
            // Reset tracking arrays
            usedCorrectItems = [];
            usedIncorrectItems = [];
            gameEnded = false;
            
            setQuestion(contentQuestion);
            
            // Hide upload buttons and start game
            hideUploadButtons();
            startGame();
        }
        
        function hideUploadButtons() {
            var uploadBtn = document.getElementById('uploadBtn');
            var downloadJsonBtn = document.getElementById('downloadJsonBtn');
            var downloadCsvBtn = document.getElementById('downloadCsvBtn');
            if (uploadBtn) uploadBtn.style.display = 'none';
            if (downloadJsonBtn) downloadJsonBtn.style.display = 'none';
            if (downloadCsvBtn) downloadCsvBtn.style.display = 'none';
        }
        
        function startGame() {
            gameStarted = true;
            gameEnded = false;
            console.log('Game started with content:', contentQuestion);
        }
        
        function endGame() {
            gameEnded = true;
            var totalCorrectItems = contentCorrect.length;
            var accuracy = totalCorrectItems > 0 ? Math.round((correctCount / totalCorrectItems) * 100) : 0;
            
            setQuestion('Game Over! Accuracy: ' + accuracy + '% (' + correctCount + '/' + totalCorrectItems + ' correct items)');
            console.log('Game ended. Final score:', correctCount, 'correct,', wrongCount, 'wrong');
            
            // Clear any remaining objects
            objects = [];
        }

        function parseCSV(csvText) {
            // Expected header: type,text OR question,text (question row optional)
            var lines = csvText.split(/\r?\n/).filter(function(l){return l.trim().length>0;});
            if (!lines.length) throw new Error('Empty CSV');
            var header = lines[0].split(',').map(function(h){return h.trim().toLowerCase();});
            var idxType = header.indexOf('type');
            var idxText = header.indexOf('text');
            var idxQuestion = header.indexOf('question');
            if (idxText === -1) throw new Error('CSV must have a text column');
            var corr = [];
            var inc = [];
            var question = 'Collect the correct items!';
            for (var i=1;i<lines.length;i++) {
                var raw = lines[i];
                var parts = raw.split(',');
                if (parts.length < 1) continue;
                if (idxQuestion !== -1 && parts[idxQuestion] && parts[idxQuestion].trim().length>0) {
                    question = parts[idxQuestion].trim();
                }
                var t = parts[idxText] ? parts[idxText].trim() : '';
                var ty = idxType !== -1 && parts[idxType] ? parts[idxType].trim().toLowerCase() : '';
                if (!t) continue;
                if (ty === 'correct') corr.push(t);
                else if (ty === 'incorrect') inc.push(t);
            }
            if (!corr.length && !inc.length) throw new Error('No rows found');
            return { question: question, correct: corr, incorrect: inc };
        }
        
        // Update score display
        function updateScore() {
            var scoreDisplay = document.getElementById('scoreDisplay');
            if (scoreDisplay) {
                scoreDisplay.innerHTML = 'Correct: ' + correctCount + ' | Wrong: ' + wrongCount;
            }
        }
        
        // Load background image
        function loadBackgroundImage() {
            roadBackground = new Image();
            roadBackground.onload = function() {
                backgroundLoaded = true;
                console.log('Background image loaded successfully');
            };
            roadBackground.onerror = function() {
                console.log('Background image failed to load, using fallback');
                backgroundLoaded = false;
            };
            // Load external background image
            roadBackground.src = 'road-background.png';
        }
        
        // Draw road with scrolling effect
        function drawRoad() {
            if (backgroundLoaded && roadBackground) {
                // Use custom background image with scrolling
                drawScrollingBackground();
            } else {
                // Fallback to original drawn road
                drawDrawnRoad();
            }
        }
        
        // Draw scrolling background image
        function drawScrollingBackground() {
            var imageHeight = roadBackground.height;
            var scrollY = roadOffset % imageHeight;
            
            // Draw the background image twice for seamless scrolling
            ctx.drawImage(roadBackground, 0, scrollY);
            ctx.drawImage(roadBackground, 0, scrollY - imageHeight);
        }
        
        // Fallback: original drawn road
        function drawDrawnRoad() {
            var roadWidth = canvas.width * 0.8; // Wider road - 80% of screen width
            var roadX = (canvas.width - roadWidth) / 2;
            
            // Road background
            ctx.fillStyle = '#34495e';
            ctx.fillRect(roadX, 0, roadWidth, canvas.height);
            
            // Scrolling lane lines
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            
            // Left lane divider - scrolling
            ctx.beginPath();
            var leftLaneX = roadX + roadWidth / 3;
            for (var y = roadOffset % 20; y < canvas.height + 20; y += 20) {
                ctx.moveTo(leftLaneX, y);
                ctx.lineTo(leftLaneX, y + 10);
            }
            ctx.stroke();
            
            // Right lane divider - scrolling
            ctx.beginPath();
            var rightLaneX = roadX + roadWidth * 2 / 3;
            for (var y = roadOffset % 20; y < canvas.height + 20; y += 20) {
                ctx.moveTo(rightLaneX, y);
                ctx.lineTo(rightLaneX, y + 10);
            }
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Road edges
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(roadX, 0);
            ctx.lineTo(roadX, canvas.height);
            ctx.moveTo(roadX + roadWidth, 0);
            ctx.lineTo(roadX + roadWidth, canvas.height);
            ctx.stroke();
        }
        
        // Draw static road (no scrolling) for game over screen
        function drawStaticRoad() {
            if (backgroundLoaded && roadBackground) {
                // Use static background image
                ctx.drawImage(roadBackground, 0, 0);
            } else {
                // Fallback to drawn static road
                drawStaticDrawnRoad();
            }
        }
        
        // Fallback: static drawn road
        function drawStaticDrawnRoad() {
            var roadWidth = canvas.width * 0.8; // Wider road - 80% of screen width
            var roadX = (canvas.width - roadWidth) / 2;
            
            // Road background
            ctx.fillStyle = '#34495e';
            ctx.fillRect(roadX, 0, roadWidth, canvas.height);
            
            // Static lane lines
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            
            // Left lane divider - static
            ctx.beginPath();
            var leftLaneX = roadX + roadWidth / 3;
            for (var y = 0; y < canvas.height + 20; y += 20) {
                ctx.moveTo(leftLaneX, y);
                ctx.lineTo(leftLaneX, y + 10);
            }
            ctx.stroke();
            
            // Right lane divider - static
            ctx.beginPath();
            var rightLaneX = roadX + roadWidth * 2 / 3;
            for (var y = 0; y < canvas.height + 20; y += 20) {
                ctx.moveTo(rightLaneX, y);
                ctx.lineTo(rightLaneX, y + 10);
            }
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Road edges
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(roadX, 0);
            ctx.lineTo(roadX, canvas.height);
            ctx.moveTo(roadX + roadWidth, 0);
            ctx.lineTo(roadX + roadWidth, canvas.height);
            ctx.stroke();
        }
        
        // Draw car
        function drawCar() {
            ctx.fillStyle = '#e67e22';
            ctx.fillRect(carX - 15, carY - 25, 30, 50);
            
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(carX - 12, carY - 22, 24, 44);
        }
        
        // Create object (single, immediate) - only unused items
        function createObjectInLane(lane) {
            var roadWidth = canvas.width * 0.8; // Match the road width
            var roadX = (canvas.width - roadWidth) / 2;
            var x = roadX + roadWidth / 6 + (lane * roadWidth / 3);
            
            // Get unused items
            var unusedCorrect = contentCorrect.filter(function(item) {
                return usedCorrectItems.indexOf(item) === -1;
            });
            var unusedIncorrect = contentIncorrect.filter(function(item) {
                return usedIncorrectItems.indexOf(item) === -1;
            });
            
            // If no unused items, end game
            if (unusedCorrect.length === 0 && unusedIncorrect.length === 0) {
                endGame();
                return;
            }
            
            // Choose random unused object
            var allUnusedObjects = unusedCorrect.concat(unusedIncorrect);
            var text = allUnusedObjects[Math.floor(Math.random() * allUnusedObjects.length)];
            var isCorrect = unusedCorrect.indexOf(text) !== -1;
            
            // Mark as used
            if (isCorrect) {
                usedCorrectItems.push(text);
            } else {
                usedIncorrectItems.push(text);
            }
            
            objects.push({
                x: x,
                y: -30,
                text: text,
                isCorrect: isCorrect,
                lane: lane,
                size: Math.max(80, text.length * 8) // Dynamic size based on text length
            });
        }

        function laneHasRecentObject(lane) {
            for (var i = 0; i < objects.length; i++) {
                var o = objects[i];
                if (o.lane === lane && o.y < minLaneGapPx) return true;
            }
            return false;
        }

        function maybeSpawn(nowMs) {
            // Don't spawn if game hasn't started or has ended
            if (!gameStarted || gameEnded) return;
            if (objects.length >= maxObjects) return;
            if (nowMs < nextSpawnAt) return;

            // Check if all items have been used
            var unusedCorrect = contentCorrect.filter(function(item) {
                return usedCorrectItems.indexOf(item) === -1;
            });
            var unusedIncorrect = contentIncorrect.filter(function(item) {
                return usedIncorrectItems.indexOf(item) === -1;
            });
            
            if (unusedCorrect.length === 0 && unusedIncorrect.length === 0) {
                endGame();
                return;
            }

            // Pick a lane different from last if possible
            var candidateLanes = [0,1,2];
            if (lastSpawnLane !== -1) {
                // rotate order to try other lanes first
                candidateLanes = [ (lastSpawnLane+1)%3, (lastSpawnLane+2)%3, lastSpawnLane ];
            }
            var chosenLane = -1;
            for (var idx=0; idx<candidateLanes.length; idx++) {
                var l = candidateLanes[idx];
                if (!laneHasRecentObject(l)) { chosenLane = l; break; }
            }
            if (chosenLane === -1) return; // lanes too crowded near top

            createObjectInLane(chosenLane);
            lastSpawnLane = chosenLane;

            // schedule next spawn
            var jitter = (Math.random()*2 - 1) * spawnJitterMs; // +/- jitter
            nextSpawnAt = nowMs + spawnIntervalMs + jitter;
        }
        
        // Draw objects
        function drawObjects() {
            for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                
                // Calculate text dimensions
                ctx.font = 'bold 12px Arial';
                var textWidth = ctx.measureText(obj.text).width;
                var textHeight = 16;
                var padding = 8;
                
                // Draw background rectangle (same color for both correct and incorrect)
                ctx.fillStyle = '#3498db'; // Blue color for all objects
                ctx.fillRect(obj.x - textWidth/2 - padding, obj.y - textHeight/2 - padding, 
                           textWidth + padding*2, textHeight + padding*2);
                
                // Draw border
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.strokeRect(obj.x - textWidth/2 - padding, obj.y - textHeight/2 - padding, 
                             textWidth + padding*2, textHeight + padding*2);
                
                // Draw text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(obj.text, obj.x, obj.y);
            }
        }
        
        // Update objects
        function updateObjects() {
            for (var i = objects.length - 1; i >= 0; i--) {
                // Objects move toward the car (downward) at game speed
                objects[i].y += gameSpeed;
                
                if (objects[i].y > canvas.height) {
                    objects.splice(i, 1);
                }
            }
        }
        
        // Check collisions
        function checkCollisions() {
            for (var i = objects.length - 1; i >= 0; i--) {
                var obj = objects[i];
                
                // Calculate object dimensions for collision
                ctx.font = 'bold 12px Arial';
                var textWidth = ctx.measureText(obj.text).width;
                var padding = 8;
                var objWidth = textWidth + padding * 2;
                var objHeight = 16 + padding * 2;
                
                // Check collision with car
                if (obj.y > carY - 25 && obj.y < carY + 25 && 
                    obj.x > carX - objWidth/2 && obj.x < carX + objWidth/2) {
                    
                    if (obj.isCorrect) {
                        correctCount++;
                    } else {
                        wrongCount++;
                    }
                    
                    updateScore();
                    objects.splice(i, 1);
                }
            }
        }
        
        // Tilt setup function - simplified for landscape
        function enableTiltControls() {
            console.log('Enabling tilt controls...');
            
            if (window.DeviceOrientationEvent) {
                // Try to request permission on iOS
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(function(response) {
                            console.log('Permission response:', response);
                            if (response === 'granted') {
                                startTiltListener();
                            } else {
                                console.log('Permission denied');
                            }
                        })
                        .catch(function(error) {
                            console.log('Permission error:', error);
                        });
                } else {
                    // No permission needed
                    startTiltListener();
                }
            } else {
                console.log('DeviceOrientationEvent not supported');
            }
        }
        
        function startTiltListener() {
            console.log('Starting tilt listener...');
            var tiltStatus = document.getElementById('tiltStatus');
            
            window.addEventListener('deviceorientation', function(e) {
                if (e.gamma !== null && e.gamma !== undefined && e.beta !== null && e.beta !== undefined) {
                    // For landscape mode, we need to use beta for left-right steering
                    // Beta is the front-to-back tilt, which becomes left-right in landscape
                    tiltX = e.beta;
                    tiltEnabled = true;
                    console.log('Tilt detected - Gamma:', e.gamma, 'Beta:', e.beta, 'Alpha:', e.alpha);
                    if (tiltStatus) {
                        tiltStatus.innerHTML = 'Tilt: Working (B:' + e.beta.toFixed(1) + ' G:' + e.gamma.toFixed(1) + ')';
                        tiltStatus.style.background = 'rgba(46, 204, 113, 0.8)';
                    }
                }
            });
            
            // Check if tilt is working after 2 seconds
            setTimeout(function() {
                if (!tiltEnabled && tiltStatus) {
                    tiltStatus.innerHTML = 'Tilt: Not Supported';
                    tiltStatus.style.background = 'rgba(231, 76, 60, 0.8)';
                }
            }, 2000);
        }
        
        // Enable tilt button
        var enableTiltBtn = document.getElementById('enableTiltBtn');
        if (enableTiltBtn) {
            enableTiltBtn.addEventListener('click', function() {
                console.log('Enable tilt button clicked');
                enableTiltControls();
                this.style.display = 'none';
            });
        }
        
        // Touch controls - back to the better version
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            isDragging = true;
        });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            if (isDragging) {
                var touch = e.touches[0];
                var roadWidth = canvas.width * 0.8; // Match the road width
                var roadX = (canvas.width - roadWidth) / 2;
                carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, touch.clientX));
            }
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            isDragging = false;
        });
        
        // Mouse controls (for testing on PC)
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                var roadWidth = canvas.width * 0.6;
                var roadX = (canvas.width - roadWidth) / 2;
                carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, e.clientX));
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            isDragging = false;
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            var roadWidth = canvas.width * 0.8; // Match the road width
            var roadX = (canvas.width - roadWidth) / 2;
            
            if (e.code === 'ArrowLeft') {
                carX = Math.max(roadX + 15, carX - 20);
            } else if (e.code === 'ArrowRight') {
                carX = Math.min(roadX + roadWidth - 15, carX + 20);
            }
        });
        
        // Update car physics for realistic steering
        function updateCarPhysics() {
            var roadWidth = canvas.width * 0.8;
            var roadX = (canvas.width - roadWidth) / 2;
            
            if (tiltEnabled && !isDragging) {
                // Convert tilt to steering input (like a steering wheel)
                var tiltFactor = Math.max(-1, Math.min(1, tiltX / 25));
                carSteering = tiltFactor;
            } else {
                // No steering input - car continues in current direction
                carSteering = 0;
            }
            
            // Apply steering to velocity (like real car physics)
            var steeringForce = carSteering * 0.15; // Reduced steering sensitivity for stability
            carVelocity += steeringForce;
            
            // Apply stronger friction to gradually slow down when not steering
            if (Math.abs(carSteering) < 0.1) {
                carVelocity *= 0.85; // Stronger friction for less wobble
            }
            
            // Limit maximum velocity (reduced for stability)
            carVelocity = Math.max(-1.5, Math.min(1.5, carVelocity));
            
            // Update car position
            carX += carVelocity;
            
            // Keep car within road boundaries
            carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, carX));
        }
        
        // Game loop
        function gameLoop(now) {
            // If game is over, just show static screen
            if (gameEnded) {
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Background
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw static road (no scrolling)
                drawStaticRoad();
                
                // Draw car in center
                drawCar();
                
                // Continue loop but don't update anything
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Update car physics
            updateCarPhysics();
            
            // Update road scrolling
            roadOffset += gameSpeed;
            
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update
            maybeSpawn(typeof now === 'number' ? now : performance.now());
            updateObjects();
            checkCollisions();
            
            // Draw
            drawRoad();
            drawCar();
            drawObjects();
            
            // Continue
            requestAnimationFrame(gameLoop);
        }
        
        // Load background image
        loadBackgroundImage();
        
        // Start the game loop (but don't spawn objects until content is uploaded)
        console.log('Game loop starting...');
        updateScore();
        // Initialize next spawn time and start loop
        nextSpawnAt = performance.now() + 600;
        requestAnimationFrame(gameLoop);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            setCanvasSize();
            carX = canvas.width / 2;
            carY = canvas.height - 100;
            debugInfo.innerHTML = 'Canvas: ' + canvas.width + 'x' + canvas.height;
        });
        
        // Full screen setup
        function requestFullScreen() {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        }
        
        // Hide address bar and try full screen
        window.addEventListener('load', function() {
            setTimeout(function() {
                window.scrollTo(0, 1);
                // Try to go full screen after a short delay
                setTimeout(requestFullScreen, 500);
            }, 0);
        });
        
        // Add full screen button
        var fullscreenBtn = document.createElement('button');
        fullscreenBtn.innerHTML = 'Full Screen';
        fullscreenBtn.style.cssText = 'position: absolute; top: 140px; left: 10px; background: #e74c3c; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;';
        fullscreenBtn.addEventListener('click', requestFullScreen);
        document.body.appendChild(fullscreenBtn);
    </script>
</body>
</html>
