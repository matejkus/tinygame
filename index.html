<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2c3e50">
    <title>Educational Car Game - Simple</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #27ae60;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #questionDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
        }
        
        #scoreDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            z-index: 100;
        }
        
        #debugInfo {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            font-size: 10px;
            z-index: 100;
        }
        
        /* Always landscape - no portrait handling */
        
        @media (orientation: landscape) {
            #questionDisplay {
                font-size: 14px;
                padding: 8px;
            }
            
            #scoreDisplay {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            #instructions {
                font-size: 10px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="questionDisplay">Collect only correct Python!</div>
        <div id="scoreDisplay">Correct: 0 | Wrong: 0</div>
        <div id="instructions">Tilt your phone (mobile) or use keyboard arrows (PC).</div>
        <div id="debugInfo">Loading...</div>
        <div id="tiltStatus" style="position: absolute; top: 110px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px; font-size: 10px; z-index: 100;">
            Tilt: Not Working
        </div>
        <button id="enableTiltBtn" style="position: absolute; top: 80px; left: 10px; background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;">
            Enable Tilt
        </button>
    </div>
    
    <!-- Optional: offline content loader. Create content.js that sets window.GAME_CONTENT = { question, correct, incorrect } -->
    <script src="content.js"></script>
    
    <script>
        console.log('Simple game starting...');
        
        // Get elements
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');
        var debugInfo = document.getElementById('debugInfo');
        var showDebugValues = true; // live debug overlay
        var lastUsingTilt = false;  // expose current control source to debug
        var lastTimestamp = null;  // for delta-time updates
        var frameDtFactor = 1;     // dt relative to 60fps (16.67ms)
        var frameDtSec = 1/60;     // dt in seconds
        
        // Set canvas size - consistent base size, scaled for larger screens
        function setCanvasSize() {
            // Base dimensions (Full HD 16:9)
            var baseWidth = 1920;
            var baseHeight = 1080;
            
            // Calculate scale factor based on screen size
            var screenWidth = Math.max(window.innerWidth, window.innerHeight);
            var screenHeight = Math.min(window.innerWidth, window.innerHeight);
            
            // Scale to COVER the viewport while preserving aspect ratio
            var scaleX = screenWidth / baseWidth;
            var scaleY = screenHeight / baseHeight;
            var scale = Math.max(scaleX, scaleY); // cover entire screen (no letterboxing)
            
            // Adjust game speed based on scale to maintain consistent feel
            gameSpeed = baseGameSpeed * scale;
            
            // Set canvas to base size (game logic uses these dimensions)
            canvas.width = baseWidth;
            canvas.height = baseHeight;
            
            // Scale the display size to cover the viewport
            var displayWidth = baseWidth * scale;
            var displayHeight = baseHeight * scale;
            
            // Center canvas
            canvas.style.position = 'absolute';
            canvas.style.top = '50%';
            canvas.style.left = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
        }
        setCanvasSize();
        
        // Update debug
        debugInfo.innerHTML = 'Canvas: ' + canvas.width + 'x' + canvas.height;
        
        // Game variables
        var carX = canvas.width / 2;
        var carY = canvas.height - 100;
        var objects = [];
        var correctCount = 0;
        var wrongCount = 0;
        var isDragging = false;
        var tiltX = 0;
        var tiltEnabled = false;
        var roadOffset = 0; // For scrolling road effect
        var baseGameSpeed = 2; // Base speed for mobile
        var gameSpeed = 2; // Will be adjusted based on screen scale
        var carSteering = 0; // Car's current steering direction (-1 to 1)
        var carVelocity = 0; // Car's horizontal velocity
        var carAngle = 0;    // Visual tilt angle (radians)
        
        // Steering/physics tuning
        var controlMaxTiltDeg = 20;   // smartphone control saturation (reach max around ±20°)
        var controlDeadzoneDeg = 4;   // small tilt ignored to prevent drift
        var steeringSensitivity = 0.22; // for desktop (keys/mouse)
        var velocityMaxDesktop = 4.0;   // desktop max sideways speed
        var velocityMaxTilt = 9.0;      // mobile tilt max sideways speed (much faster than desktop)
        var frictionWhenNoInput = 0.92; // friction for desktop
        var tiltResponse = 0.35;        // how fast car eases to target speed on tilt (0-1)
        var tiltCurveExp = 1.6;         // >1 increases contrast: B:10 slower, B:20 near max
        
        // Desktop control state
        var inputAxis = 0; // -1 left, 1 right, 0 none
        var keyLeftDown = false;
        var keyRightDown = false;
        var lastPointerX = null; // for mouse/touch deltas
        
        // Parallax for background layers
        var staticOffset = 0;
        var staticParallaxFactor = 0.08; // very slow relative to gameSpeed
        var midOffset = 0;
        var midParallaxFactor = 0.20;    // slower than foreground, faster than static
        
        // Background image system (multi-layer)
        var staticBackground = null;   // non-scrolling layer
        var midOverlay = null;         // mid parallax overlay (slow)
        var scrollOverlay = null;      // fast scrolling road lines layer
        var staticLoaded = false;
        var midLoaded = false;
        var scrollLoaded = false;

        // Vehicle sprite
        var vehicleImage = null;
        var vehicleLoaded = false;
        // Object background sprite
        var objectBgImage = null;
        var objectBgLoaded = false;
        
        // Spawn control (consistent pacing)
        var spawnIntervalMs = 1800; // base interval between spawns (increased for more thinking time)
        var spawnJitterMs = 600;   // random variation to avoid perfect rhythm
        var nextSpawnAt = 0;       // timestamp (ms) when next spawn is allowed
        var maxObjects = 2;        // cap concurrent objects (reduced for less clutter)
        var minLaneGapPx = 200;    // minimal vertical gap within same lane (increased)
        var lastSpawnLane = -1;    // remember previous lane to rotate fairly

        // Content state (starts empty - must be uploaded)
        var contentQuestion = '';
        var contentCorrect = [];
        var contentIncorrect = [];
        var gameStarted = false;
        
        // Track which items have been used (to avoid repeats)
        var usedCorrectItems = [];
        var usedIncorrectItems = [];
        var gameEnded = false;

        function setQuestion(text) {
            var q = document.getElementById('questionDisplay');
            if (q) q.textContent = text;
        }
        
        // Show loading prompt initially
        function showLoadingPrompt() {
            setQuestion('Loading content...');
        }
        showLoadingPrompt();

        // Auto content loading at startup (JSON or CSV from repo)
        function tryLoadContent() {
            // 1) If content provided via content.js (works over file://), use it
            if (window && window.GAME_CONTENT) {
                try {
                    applyUploadedContent(window.GAME_CONTENT);
                    return;
                } catch (e) {
                    console.error('Invalid GAME_CONTENT format', e);
                    setQuestion('Invalid GAME_CONTENT provided.');
                    return;
                }
            }

            if (location && location.protocol === 'file:') {
                console.error('Cannot fetch local files over file:// due to browser restrictions.');
                setQuestion('Cannot load content over file://. Please serve the folder via a local web server or deploy (e.g., GitHub Pages).');
                return;
            }
            // Prefer JSON if present, otherwise CSV; filenames can be changed in repo
            var candidates = ['content.json', 'content.csv'];
            (function tryNext(idx){
                if (idx >= candidates.length) {
                    console.error('No content file found.');
                    setQuestion('No content found. Please add content.json or content.csv.');
                    return;
                }
                var url = candidates[idx];
                fetch(url, { cache: 'no-store' })
                    .then(function(res){
                        if (!res.ok) throw new Error('HTTP ' + res.status);
                        return res.text();
                    })
                    .then(function(text){
                        try {
                            if (/^\s*\{/.test(text)) {
                                var data = JSON.parse(text);
                                applyUploadedContent(data);
                            } else {
                                var data = parseCSV(text);
                                applyUploadedContent(data);
                            }
                        } catch (e) {
                            console.error('Failed to parse content file', url, e);
                            setQuestion('Failed to parse ' + url + '.');
                        }
                    })
                    .catch(function(err){
                        console.error('Fetch failed for', url, err);
                        // try next candidate
                        tryNext(idx+1);
                    });
            })(0);
        }

        // Sample content (Big Data topic)
        function getSampleContent() {
            return {
                question: "Collect only things that are 'big data'",
                correct: [
                    'Social media activity logs',
                    'IoT sensor streams from thousands of devices',
                    'Clickstream data from a major e‑commerce site',
                    'Web server logs at internet scale',
                    'Satellite imagery archives updated daily',
                    'Global financial transaction streams',
                    'Telemetry from millions of connected cars',
                    'Genome sequencing datasets across populations',
                    'Email delivery logs from a large provider',
                    'Ad impression and auction logs'
                ],
                incorrect: [
                    'A 2 GB video file',
                    'A ZIP of vacation photos',
                    'A single machine\'s log file',
                    'An Excel sheet with thousands of rows',
                    'A local database with 100k records',
                    'A PDF archive of reports',
                    'A full hard‑drive backup',
                    'One HD movie file',
                    'A large PSD design file',
                    'A 500 MB CSV export'
                ]
            };
        }

        function downloadBlob(filename, text, mime) {
            var blob = new Blob([text], { type: mime || 'text/plain' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(function(){
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }

        function downloadSampleJSON() {
            var data = getSampleContent();
            var text = JSON.stringify(data, null, 2);
            downloadBlob('sample-content.json', text, 'application/json');
        }

        function downloadSampleCSV() {
            var data = getSampleContent();
            var lines = [];
            lines.push('type,text,question');
            // Put question only on the first row to keep it concise
            if (data.correct && data.correct.length) {
                lines.push('correct,"' + data.correct[0].replace(/"/g,'""') + '","' + data.question.replace(/"/g,'""') + '"');
                for (var i=1;i<data.correct.length;i++) {
                    lines.push('correct,"' + data.correct[i].replace(/"/g,'""') + '",');
                }
            }
            if (data.incorrect && data.incorrect.length) {
                for (var j=0;j<data.incorrect.length;j++) {
                    lines.push('incorrect,"' + data.incorrect[j].replace(/"/g,'""') + '",');
                }
            }
            downloadBlob('sample-content.csv', lines.join('\n'), 'text/csv');
        }

        // Removed sample download UI; helper functions kept for reference if needed

        function applyUploadedContent(data) {
            // JSON format: { question: string, correct: string[], incorrect: string[] }
            // CSV parsed format: { question, correct, incorrect }
            var q = data.question || 'Collect the correct items!';
            var corr = Array.isArray(data.correct) ? data.correct : [];
            var inc = Array.isArray(data.incorrect) ? data.incorrect : [];
            if (!corr.length || !inc.length) throw new Error('Lists cannot be empty');
            contentQuestion = q;
            contentCorrect = corr;
            contentIncorrect = inc;
            
            // Reset tracking arrays
            usedCorrectItems = [];
            usedIncorrectItems = [];
            gameEnded = false;
            
            setQuestion(contentQuestion);
            
            startGame();
        }
        
        function startGame() {
            gameStarted = true;
            gameEnded = false;
            console.log('Game started with content:', contentQuestion);
        }
        
        function endGame() {
            gameEnded = true;
            var totalCorrectItems = contentCorrect.length;
            var accuracy = totalCorrectItems > 0 ? Math.round((correctCount / totalCorrectItems) * 100) : 0;
            
            setQuestion('Game Over! Accuracy: ' + accuracy + '% (' + correctCount + '/' + totalCorrectItems + ' correct items)');
            console.log('Game ended. Final score:', correctCount, 'correct,', wrongCount, 'wrong');
            
            // Clear any remaining objects
            objects = [];
        }

        function parseCSV(csvText) {
            // Expected header: type,text OR question,text (question row optional)
            var lines = csvText.split(/\r?\n/).filter(function(l){return l.trim().length>0;});
            if (!lines.length) throw new Error('Empty CSV');
            var header = lines[0].split(',').map(function(h){return h.trim().toLowerCase();});
            var idxType = header.indexOf('type');
            var idxText = header.indexOf('text');
            var idxQuestion = header.indexOf('question');
            if (idxText === -1) throw new Error('CSV must have a text column');
            var corr = [];
            var inc = [];
            var question = 'Collect the correct items!';
            for (var i=1;i<lines.length;i++) {
                var raw = lines[i];
                var parts = raw.split(',');
                if (parts.length < 1) continue;
                if (idxQuestion !== -1 && parts[idxQuestion] && parts[idxQuestion].trim().length>0) {
                    question = parts[idxQuestion].trim();
                }
                var t = parts[idxText] ? parts[idxText].trim() : '';
                var ty = idxType !== -1 && parts[idxType] ? parts[idxType].trim().toLowerCase() : '';
                if (!t) continue;
                if (ty === 'correct') corr.push(t);
                else if (ty === 'incorrect') inc.push(t);
            }
            if (!corr.length && !inc.length) throw new Error('No rows found');
            return { question: question, correct: corr, incorrect: inc };
        }
        
        // Update score display
        function updateScore() {
            var scoreDisplay = document.getElementById('scoreDisplay');
            if (scoreDisplay) {
                scoreDisplay.innerHTML = 'Correct: ' + correctCount + ' | Wrong: ' + wrongCount;
            }
        }
        
        // Load all image assets
        function loadAssets() {
            // Static background
            staticBackground = new Image();
            staticBackground.onload = function() {
                staticLoaded = true;
                console.log('Static background loaded');
            };
            staticBackground.onerror = function onStaticError() {
                // Try .jpg fallback once if .png missing
                if (staticBackground && /background-static\.png$/i.test(staticBackground.src)) {
                    console.log('Static .png not found, trying background-static.jpg');
                    staticBackground.onerror = function() {
                        console.log('Static background failed to load, using fallback fill');
                        staticLoaded = false;
                    };
                    staticBackground.src = 'background-static.jpg';
                } else {
                    console.log('Static background failed to load, using fallback fill');
                    staticLoaded = false;
                }
            };
            try {
                staticBackground.src = 'background-static.png'; // Prefer .png; falls back to .jpg
            } catch (e) {
                staticLoaded = false;
            }

            // Mid overlay (slow)
            midOverlay = new Image();
            midOverlay.onload = function() {
                midLoaded = true;
                console.log('Mid overlay loaded');
            };
            midOverlay.onerror = function() {
                console.log('Mid overlay failed to load (optional)');
                midLoaded = false;
            };
            try {
                midOverlay.src = 'background-mid.png';
            } catch (e) {
                midLoaded = false;
            }

            // Scrolling overlay (fast)
            scrollOverlay = new Image();
            scrollOverlay.onload = function() {
                scrollLoaded = true;
                console.log('Scrolling overlay loaded');
            };
            scrollOverlay.onerror = function() {
                console.log('Scrolling overlay failed to load, using drawn road');
                scrollLoaded = false;
            };
            try {
                scrollOverlay.src = 'background-scroll.png'; // Provide this image
            } catch (e) {
                scrollLoaded = false;
            }

            // Vehicle image
            vehicleImage = new Image();
            vehicleImage.onload = function() {
                vehicleLoaded = true;
                console.log('Vehicle image loaded');
            };
            vehicleImage.onerror = function() {
                vehicleLoaded = false;
                console.log('Vehicle image failed to load, using fallback rectangle');
            };
            try {
                vehicleImage.src = 'vehicle.png';
            } catch (e) {
                vehicleLoaded = false;
            }

            // Object background image
            objectBgImage = new Image();
            objectBgImage.onload = function() {
                objectBgLoaded = true;
                console.log('Object background loaded');
            };
            objectBgImage.onerror = function() {
                objectBgLoaded = false;
                console.log('Object background failed to load, using rectangle fallback');
            };
            try {
                objectBgImage.src = 'object_background.png';
            } catch (e) {
                objectBgLoaded = false;
            }
        }
        
        // Draw road with two layers (static + scrolling overlay)
        function drawRoad() {
            // Base fill (in case static not provided)
            if (!staticLoaded) {
                // Grass background
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                drawScrollingStaticBackground();
            }

            if (midLoaded) {
                drawScrollingMidOverlay();
            }

            if (scrollLoaded) {
                drawScrollingOverlay();
            } else {
                // Fallback to original drawn road lines if overlay missing
                drawDrawnRoad();
            }
        }
        
        // Draw static background layer with very slow scrolling (parallax)
        function drawScrollingStaticBackground() {
            var iw = staticBackground.width;
            var ih = staticBackground.height;
            var scaleX = canvas.width / iw;
            var scaleY = canvas.height / ih;
            var scale = Math.max(scaleX, scaleY); // cover
            var sw = iw * scale;
            var sh = ih * scale;
            var offsetX = (canvas.width - sw) / 2;
            var scrollY = staticOffset % sh;
            ctx.drawImage(staticBackground, offsetX, scrollY, sw, sh);
            ctx.drawImage(staticBackground, offsetX, scrollY - sh, sw, sh);
        }

        // Draw scrolling overlay image, tiled vertically
        function drawScrollingOverlay() {
            var ih = scrollOverlay.height;
            var iw = scrollOverlay.width;
            var scaleX = canvas.width / iw;
            var scaleY = canvas.height / ih;
            var scale = Math.max(scaleX, scaleY);
            var sw = iw * scale;
            var sh = ih * scale;
            var offsetX = (canvas.width - sw) / 2;
            var scrollY = roadOffset % sh;
            ctx.drawImage(scrollOverlay, offsetX, scrollY, sw, sh);
            ctx.drawImage(scrollOverlay, offsetX, scrollY - sh, sw, sh);
        }

        // Draw mid overlay image, tiled vertically (slow parallax)
        function drawScrollingMidOverlay() {
            var ih = midOverlay.height;
            var iw = midOverlay.width;
            var scaleX = canvas.width / iw;
            var scaleY = canvas.height / ih;
            var scale = Math.max(scaleX, scaleY);
            var sw = iw * scale;
            var sh = ih * scale;
            var offsetX = (canvas.width - sw) / 2;
            var scrollY = midOffset % sh;
            ctx.drawImage(midOverlay, offsetX, scrollY, sw, sh);
            ctx.drawImage(midOverlay, offsetX, scrollY - sh, sw, sh);
        }
        
        // Fallback: original drawn road
        function drawDrawnRoad() {
            var roadWidth = canvas.width * 0.8; // Wider road - 80% of screen width
            var roadX = (canvas.width - roadWidth) / 2;
            
            // Road background
            ctx.fillStyle = '#34495e';
            ctx.fillRect(roadX, 0, roadWidth, canvas.height);
            
            // Scrolling lane lines
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            
            // Left lane divider - scrolling
            ctx.beginPath();
            var leftLaneX = roadX + roadWidth / 3;
            for (var y = roadOffset % 20; y < canvas.height + 20; y += 20) {
                ctx.moveTo(leftLaneX, y);
                ctx.lineTo(leftLaneX, y + 10);
            }
            ctx.stroke();
            
            // Right lane divider - scrolling
            ctx.beginPath();
            var rightLaneX = roadX + roadWidth * 2 / 3;
            for (var y = roadOffset % 20; y < canvas.height + 20; y += 20) {
                ctx.moveTo(rightLaneX, y);
                ctx.lineTo(rightLaneX, y + 10);
            }
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Road edges
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(roadX, 0);
            ctx.lineTo(roadX, canvas.height);
            ctx.moveTo(roadX + roadWidth, 0);
            ctx.lineTo(roadX + roadWidth, canvas.height);
            ctx.stroke();
        }
        
        // Draw static road (no scrolling) for game over screen
        function drawStaticRoad() {
            if (staticLoaded) {
                drawStaticBackgroundScaled();
            } else {
                // Fallback to drawn static road
                drawStaticDrawnRoad();
            }
        }
        
        // Fallback: static drawn road
        function drawStaticDrawnRoad() {
            var roadWidth = canvas.width * 0.8; // Wider road - 80% of screen width
            var roadX = (canvas.width - roadWidth) / 2;
            
            // Road background
            ctx.fillStyle = '#34495e';
            ctx.fillRect(roadX, 0, roadWidth, canvas.height);
            
            // Static lane lines
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            
            // Left lane divider - static
            ctx.beginPath();
            var leftLaneX = roadX + roadWidth / 3;
            for (var y = 0; y < canvas.height + 20; y += 20) {
                ctx.moveTo(leftLaneX, y);
                ctx.lineTo(leftLaneX, y + 10);
            }
            ctx.stroke();
            
            // Right lane divider - static
            ctx.beginPath();
            var rightLaneX = roadX + roadWidth * 2 / 3;
            for (var y = 0; y < canvas.height + 20; y += 20) {
                ctx.moveTo(rightLaneX, y);
                ctx.lineTo(rightLaneX, y + 10);
            }
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Road edges
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(roadX, 0);
            ctx.lineTo(roadX, canvas.height);
            ctx.moveTo(roadX + roadWidth, 0);
            ctx.lineTo(roadX + roadWidth, canvas.height);
            ctx.stroke();
        }
        
        // Draw car
        function drawCar() {
            // Car size relative to canvas height
            var carSize = Math.max(96, Math.round(canvas.height * 0.16)); // ~16% of height (2x bigger)
            ctx.save();
            ctx.translate(carX, carY);
            ctx.rotate(carAngle || 0);
            if (vehicleLoaded && vehicleImage) {
                ctx.drawImage(vehicleImage, -carSize/2, -carSize/2, carSize, carSize);
            } else {
                // Fallback rectangle car
                ctx.fillStyle = '#e67e22';
                ctx.fillRect(-carSize*0.25, -carSize*0.4, carSize*0.5, carSize*0.8);
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(-carSize*0.2, -carSize*0.33, carSize*0.4, carSize*0.66);
            }
            ctx.restore();
        }
        
        // Create object (single, immediate) - only unused items
        function createObjectInLane(lane) {
            var roadWidth = canvas.width * 0.8; // Match the road width
            var roadX = (canvas.width - roadWidth) / 2;
            var x = roadX + roadWidth / 6 + (lane * roadWidth / 3);
            
            // Get unused items
            var unusedCorrect = contentCorrect.filter(function(item) {
                return usedCorrectItems.indexOf(item) === -1;
            });
            var unusedIncorrect = contentIncorrect.filter(function(item) {
                return usedIncorrectItems.indexOf(item) === -1;
            });
            
            // If no unused items, end game
            if (unusedCorrect.length === 0 && unusedIncorrect.length === 0) {
                endGame();
                return;
            }
            
            // Choose random unused object
            var allUnusedObjects = unusedCorrect.concat(unusedIncorrect);
            var text = allUnusedObjects[Math.floor(Math.random() * allUnusedObjects.length)];
            var isCorrect = unusedCorrect.indexOf(text) !== -1;
            
            // Mark as used
            if (isCorrect) {
                usedCorrectItems.push(text);
            } else {
                usedIncorrectItems.push(text);
            }
            
            objects.push({
                x: x,
                y: -30,
                text: text,
                isCorrect: isCorrect,
                lane: lane,
                size: Math.max(80, text.length * 8) // Dynamic size based on text length
            });
        }

        function laneHasRecentObject(lane) {
            for (var i = 0; i < objects.length; i++) {
                var o = objects[i];
                if (o.lane === lane && o.y < minLaneGapPx) return true;
            }
            return false;
        }

        function maybeSpawn(nowMs) {
            // Don't spawn if game hasn't started or has ended
            if (!gameStarted || gameEnded) return;
            if (objects.length >= maxObjects) return;
            if (nowMs < nextSpawnAt) return;

            // Check if all items have been used
            var unusedCorrect = contentCorrect.filter(function(item) {
                return usedCorrectItems.indexOf(item) === -1;
            });
            var unusedIncorrect = contentIncorrect.filter(function(item) {
                return usedIncorrectItems.indexOf(item) === -1;
            });
            
            if (unusedCorrect.length === 0 && unusedIncorrect.length === 0) {
                endGame();
                return;
            }

            // Pick a lane different from last if possible
            var candidateLanes = [0,1,2];
            if (lastSpawnLane !== -1) {
                // rotate order to try other lanes first
                candidateLanes = [ (lastSpawnLane+1)%3, (lastSpawnLane+2)%3, lastSpawnLane ];
            }
            var chosenLane = -1;
            for (var idx=0; idx<candidateLanes.length; idx++) {
                var l = candidateLanes[idx];
                if (!laneHasRecentObject(l)) { chosenLane = l; break; }
            }
            if (chosenLane === -1) return; // lanes too crowded near top

            createObjectInLane(chosenLane);
            lastSpawnLane = chosenLane;

            // schedule next spawn
            var jitter = (Math.random()*2 - 1) * spawnJitterMs; // +/- jitter
            nextSpawnAt = nowMs + spawnIntervalMs + jitter;
        }
        
        // Compute object card size (keeps 500x300 aspect ratio by default)
        function getObjectCardSize() {
            // Bigger for phone readability (~14% of canvas height)
            var baseH = Math.max(100, Math.round(canvas.height * 0.14));
            var ratio = 500 / 300;
            if (objectBgLoaded && objectBgImage && objectBgImage.width && objectBgImage.height) {
                ratio = objectBgImage.width / objectBgImage.height;
            }
            var w = Math.round(baseH * ratio);
            return { w: w, h: baseH };
        }

        // Wrap text into up to maxLines to fit maxWidth; returns array of lines
        function wrapTextLines(ctx, text, maxWidth, maxLines) {
            var words = String(text || '').split(/\s+/);
            var lines = [];
            var current = '';
            for (var i = 0; i < words.length; i++) {
                var test = current ? (current + ' ' + words[i]) : words[i];
                if (ctx.measureText(test).width <= maxWidth) {
                    current = test;
                } else {
                    if (current) lines.push(current);
                    else {
                        // Very long single word: hard-break
                        var word = words[i];
                        var chunk = '';
                        for (var c = 0; c < word.length; c++) {
                            var t2 = chunk + word[c];
                            if (ctx.measureText(t2).width <= maxWidth) chunk = t2; else { lines.push(chunk); chunk = word[c]; }
                        }
                        current = chunk;
                    }
                    current = words[i];
                }
                if (lines.length >= maxLines) break;
            }
            if (lines.length < maxLines && current) lines.push(current);
            if (lines.length > maxLines) {
                // Collapse overflow into last line with ellipsis
                var keep = lines.slice(0, maxLines - 1).join(' ');
                var rest = words.slice(words.indexOf(lines[maxLines - 1].split(/\s+/)[0])).join(' ');
                var last = lines[maxLines - 1] || '';
                var ell = '…';
                while (ctx.measureText(last + ell).width > maxWidth && last.length > 0) {
                    last = last.slice(0, -1);
                }
                lines = lines.slice(0, maxLines - 1);
                lines.push(last + ell);
            }
            return lines;
        }

        // Fit text: auto font size and wrapped lines to fit within card
        function layoutObjectText(ctx, text, w, h) {
            var maxFont = Math.max(16, Math.floor(h * 0.36));
            var minFont = 12;
            var chosen = minFont;
            var lines = [String(text || '')];
            for (var fs = maxFont; fs >= minFont; fs--) {
                ctx.font = 'bold ' + fs + 'px Arial';
                var candidate = wrapTextLines(ctx, text, w * 0.86, 3); // up to 3 rows
                var lineHeight = Math.round(fs * 1.12);
                var totalH = candidate.length * lineHeight;
                if (candidate.length <= 3 && totalH <= h * 0.8) {
                    chosen = fs;
                    lines = candidate;
                    break;
                }
            }
            return { fontSize: chosen, lines: lines, lineHeight: Math.round(chosen * 1.12) };
        }
 
        // Draw objects
        function drawObjects() {
            for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                var sz = getObjectCardSize();
                var w = sz.w, h = sz.h;

                // Draw background image or fallback
                if (objectBgLoaded) {
                    ctx.drawImage(objectBgImage, obj.x - w/2, obj.y - h/2, w, h);
                } else {
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(obj.x - w/2, obj.y - h/2, w, h);
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x - w/2, obj.y - h/2, w, h);
                }

                // Draw wrapped text (2-3 lines) centered
                var layout = layoutObjectText(ctx, obj.text, w, h);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold ' + layout.fontSize + 'px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0,0,0,0.45)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetY = 1;
                var totalH = layout.lines.length * layout.lineHeight;
                var startY = obj.y - totalH / 2 + layout.lineHeight / 2;
                for (var li = 0; li < layout.lines.length; li++) {
                    ctx.fillText(layout.lines[li], obj.x, startY + li * layout.lineHeight);
                }
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
            }
        }
        
        // Update objects
        function updateObjects() {
            for (var i = objects.length - 1; i >= 0; i--) {
                // Objects move toward the car (downward) at game speed
                objects[i].y += gameSpeed * frameDtFactor;
                
                if (objects[i].y > canvas.height) {
                    objects.splice(i, 1);
                }
            }
        }
        
        // Check collisions
        function checkCollisions() {
            for (var i = objects.length - 1; i >= 0; i--) {
                var obj = objects[i];
                // Object dimensions based on card size
                var card = getObjectCardSize();
                var objWidth = card.w;
                var objHeight = card.h;
                
                // Check collision with car (simple AABB approximation)
                if (obj.y > carY - 25 && obj.y < carY + 25 &&
                    obj.x > carX - objWidth/2 && obj.x < carX + objWidth/2) {
                    
                    if (obj.isCorrect) {
                        correctCount++;
                    } else {
                        wrongCount++;
                    }
                    
                    updateScore();
                    objects.splice(i, 1);
                }
            }
        }
        
        // Tilt setup function - simplified for landscape
        function enableTiltControls() {
            console.log('Enabling tilt controls...');
            
            if (window.DeviceOrientationEvent) {
                // Try to request permission on iOS
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(function(response) {
                            console.log('Permission response:', response);
                            if (response === 'granted') {
                                startTiltListener();
                            } else {
                                console.log('Permission denied');
                            }
                        })
                        .catch(function(error) {
                            console.log('Permission error:', error);
                        });
                } else {
                    // No permission needed
                    startTiltListener();
                }
            } else {
                console.log('DeviceOrientationEvent not supported');
            }
        }
        
        function startTiltListener() {
            console.log('Starting tilt listener...');
            var tiltStatus = document.getElementById('tiltStatus');
            
            window.addEventListener('deviceorientation', function(e) {
                if (e.gamma !== null && e.gamma !== undefined && e.beta !== null && e.beta !== undefined) {
                    // For landscape mode, we need to use beta for left-right steering
                    tiltX = e.beta;

                    // Invert controls if phone is in upside-down landscape
                    if (screen && screen.orientation && screen.orientation.type === 'landscape-secondary') {
                        tiltX = -tiltX;
                    }

                    tiltEnabled = true;
                    console.log('Tilt detected - Gamma:', e.gamma, 'Beta:', e.beta, 'Alpha:', e.alpha);
                    if (tiltStatus) {
                        tiltStatus.innerHTML = 'Tilt: Working (B:' + e.beta.toFixed(1) + ' G:' + e.gamma.toFixed(1) + ')';
                        tiltStatus.style.background = 'rgba(46, 204, 113, 0.8)';
                    }
                }
            });
            
            // Check if tilt is working after 2 seconds
            setTimeout(function() {
                if (!tiltEnabled && tiltStatus) {
                    tiltStatus.innerHTML = 'Tilt: Not Supported';
                    tiltStatus.style.background = 'rgba(231, 76, 60, 0.8)';
                }
            }, 2000);
        }
        
        // Enable tilt button
        var enableTiltBtn = document.getElementById('enableTiltBtn');
        if (enableTiltBtn) {
            enableTiltBtn.addEventListener('click', function() {
                console.log('Enable tilt button clicked');
                enableTiltControls();
                this.style.display = 'none';
            });
        }
        
        // Touch controls disabled per user request (tilt + keyboard only)
        // canvas.addEventListener('touchstart', function(e) {
        //     e.preventDefault();
        //     isDragging = true;
        // });
        // 
        // canvas.addEventListener('touchmove', function(e) {
        //     e.preventDefault();
        //     if (isDragging) {
        //         var touch = e.touches[0];
        //         var roadWidth = canvas.width * 0.8; // Match the road width
        //         var roadX = (canvas.width - roadWidth) / 2;
        //         carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, touch.clientX));
        //     }
        // });
        // 
        // canvas.addEventListener('touchend', function(e) {
        //     e.preventDefault();
        //     isDragging = false;
        // });
        
        // Mouse controls (PC): horizontal drag sets position and steering axis
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastPointerX = e.clientX;
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                var roadWidth = canvas.width * 0.8;
                var roadX = (canvas.width - roadWidth) / 2;
                var dx = lastPointerX !== null ? (e.clientX - lastPointerX) : 0;
                lastPointerX = e.clientX;
                // Update steering axis from mouse delta (scaled)
                inputAxis = Math.max(-1, Math.min(1, dx / 40));
                // Position follow (optional, keep like before)
                carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, e.clientX));
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            isDragging = false;
            lastPointerX = null;
            inputAxis = 0; // stop steering when mouse released
        });
        
        // Keyboard controls with steering axis
        document.addEventListener('keydown', function(e) {
            var roadWidth = canvas.width * 0.8; // Match the road width
            var roadX = (canvas.width - roadWidth) / 2;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keyLeftDown = true;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keyRightDown = true;
            }
            // Nudge position for discrete key press feel
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                carX = Math.max(roadX + 15, carX - 14);
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                carX = Math.min(roadX + roadWidth - 15, carX + 14);
            }
            // Update axis from keys
            inputAxis = (keyRightDown ? 1 : 0) + (keyLeftDown ? -1 : 0);
        });

        document.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keyLeftDown = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keyRightDown = false;
            }
            inputAxis = (keyRightDown ? 1 : 0) + (keyLeftDown ? -1 : 0);
        });
        
        // Update car physics for realistic steering
        function updateCarPhysics() {
            var roadWidth = canvas.width * 0.8;
            var roadX = (canvas.width - roadWidth) / 2;
            
            // Prefer tilt when it's meaningfully active
            var tiltActive = tiltEnabled && Math.abs(tiltX) > (controlDeadzoneDeg + 0.5); // hysteresis
            var usingTilt = !!tiltActive;
            lastUsingTilt = usingTilt;
            
            if (usingTilt) {
                // --- TILT: DIRECT VELOCITY CONTROL ---
                // 1. Calculate normalized tilt (0 to 1) with a deadzone. This is a linear mapping.
                var mag = Math.max(0, Math.abs(tiltX) - controlDeadzoneDeg);
                var range = controlMaxTiltDeg - controlDeadzoneDeg;
                var norm = range > 0 ? Math.min(1, mag / range) : 0;
                
                // 2. Map the normalized tilt directly to a target velocity.
                var sign = tiltX < 0 ? -1 : 1;
                var shaped = Math.pow(norm, tiltCurveExp);
                var targetVelocity = shaped * velocityMaxTilt * sign;
                
                // 3. Smoothly ease the car's current velocity towards the target velocity.
                var tiltLerp = 1 - Math.pow(1 - tiltResponse, frameDtFactor);
                carVelocity += (targetVelocity - carVelocity) * tiltLerp;

            } else { 
                // --- DESKTOP: ACCELERATION-BASED CONTROL ---
                var isActivelySteering = Math.abs(inputAxis) > 0.01;
                var carSteering = isActivelySteering ? Math.max(-1, Math.min(1, inputAxis)) : 0;
                
                // Apply acceleration force.
                var steeringForce = carSteering * steeringSensitivity * frameDtFactor;
                carVelocity += steeringForce;
                
                // Apply friction only when not actively steering.
                if (!isActivelySteering) {
                    var frictionPow = Math.pow(frictionWhenNoInput, frameDtFactor);
                    carVelocity *= frictionPow;
                }
            }
            
            // --- COMMON PHYSICS ---
            // Safeguard to ensure velocity doesn't exceed the maximum.
            var currentMax = lastUsingTilt ? velocityMaxTilt : velocityMaxDesktop;
            carVelocity = Math.max(-currentMax, Math.min(currentMax, carVelocity));
            
            // Update car position.
            carX += carVelocity * frameDtFactor;
            
            // Keep car within road boundaries.
            carX = Math.max(roadX + 15, Math.min(roadX + roadWidth - 15, carX));

            // Smoothly update visual tilt angle based on velocity.
            var maxTiltDeg = 15; // maximum visual banking angle
            var targetAngle = (carVelocity / currentMax) * (maxTiltDeg * Math.PI / 180);
            carAngle = carAngle || 0;
            carAngle += (targetAngle - carAngle) * 0.2; // smoothing factor
        }
        
        // Game loop
        function gameLoop(now) {
            // Delta time (normalize to 60fps)
            if (typeof now === 'number') {
                if (lastTimestamp === null) lastTimestamp = now;
                var dtMs = now - lastTimestamp;
                lastTimestamp = now;
                // Clamp to avoid giant jumps
                if (!isFinite(dtMs) || dtMs <= 0) dtMs = 16.6667;
                if (dtMs > 250) dtMs = 250;
                frameDtFactor = dtMs / 16.6667;
                frameDtSec = dtMs / 1000;
            } else {
                frameDtFactor = 1;
                frameDtSec = 1/60;
            }
            // If game is over, just show static screen
            if (gameEnded) {
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Background
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw static road (no scrolling)
                drawStaticRoad();
                
                // Draw car in center
                drawCar();
                
                // Continue loop but don't update anything
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Update car physics
            updateCarPhysics();
            
            // Update road scrolling (delta-time based)
            roadOffset += gameSpeed * frameDtFactor;
            staticOffset += gameSpeed * staticParallaxFactor * frameDtFactor;
            midOffset += gameSpeed * midParallaxFactor * frameDtFactor;
            
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update
            maybeSpawn(typeof now === 'number' ? now : performance.now());
            updateObjects();
            checkCollisions();
            
            // Draw
            drawRoad();
            drawCar();
            drawObjects();
            
            // Live debug overlay
            if (showDebugValues && debugInfo) {
                debugInfo.innerHTML = 'Canvas: ' + canvas.width + 'x' + canvas.height +
                    '<br>tiltEnabled: ' + tiltEnabled + ' usingTilt: ' + lastUsingTilt +
                    '<br>tiltX(B): ' + (typeof tiltX === 'number' ? tiltX.toFixed(1) : 'n/a') +
                    '<br>inputAxis: ' + inputAxis.toFixed(2) +
                    '<br>carVelocity(px/s-frame@60): ' + carVelocity.toFixed(2) +
                    '<br>dt(ms): ' + (frameDtSec*1000).toFixed(2) + ' factor: ' + frameDtFactor.toFixed(2);
            }

            // Continue
            requestAnimationFrame(gameLoop);
        }
        
        // Load assets (backgrounds + vehicle) and content
        loadAssets();
        tryLoadContent();
        
        // Start the game loop (but don't spawn objects until content is uploaded)
        console.log('Game loop starting...');
        updateScore();
        // Initialize next spawn time and start loop
        nextSpawnAt = performance.now() + 600;
        requestAnimationFrame(gameLoop);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            setCanvasSize();
            carX = canvas.width / 2;
            carY = canvas.height - 100;
            debugInfo.innerHTML = 'Canvas: ' + canvas.width + 'x' + canvas.height;
        });
        
        // Full screen setup
        function requestFullScreen() {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        }
        
        // Hide address bar and try full screen
        window.addEventListener('load', function() {
            setTimeout(function() {
                window.scrollTo(0, 1);
                // Try to go full screen after a short delay
                setTimeout(requestFullScreen, 500);
            }, 0);
        });
        
        // Add full screen button
        var fullscreenBtn = document.createElement('button');
        fullscreenBtn.innerHTML = 'Full Screen';
        fullscreenBtn.style.cssText = 'position: absolute; top: 140px; left: 10px; background: #e74c3c; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 100;';
        fullscreenBtn.addEventListener('click', requestFullScreen);
        document.body.appendChild(fullscreenBtn);
    </script>
</body>
</html>
